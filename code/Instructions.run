
-- https://github.com/takahirox/riscv-rust/blob/master/src/cpu.rs

local prefixes = {
	I = {
		cpp = [[{
			auto f = parseFormatI(word);
			TRACE(str(L"\tI: R(%d) = R(%d) op %d", f.rd, f.rs1, f.imm));
			TRACE(str(L"\t   R(%d) = %08x", f.rs1, R_s(f.rs1)));
		}]],
		verilog = [[
			$display("\tI: R(%d) = R(%d) op %d (%d)", inst_I_rd, inst_I_rs1, inst_I_imm, $signed(inst_I_imm));
			$display("\t   R(%d) = %x", inst_I_rs1, r[inst_I_rs1]);
		]]
	},
	J = {
		cpp = [[{
			auto f = parseFormatJ(word);
			TRACE(str(L"\tJ: R(%d), imm %d", f.rd, f.imm));
		}]],
		verilog = [[
			$display("\tJ: R(%d), imm %d (%d)", inst_J_rd, inst_J_imm, $signed(inst_J_imm));
		]]
	},	
	R = {
		verilog = [[
			$display("\tR: R(%d) = R(%d) op R(%d)", inst_R_rd, inst_R_rs1, inst_R_rs2);
		]]
	},
	U = {
		verilog = [[
			$display("\tU: R(%d), imm %d (%d)", inst_U_rd, inst_U_imm, $signed(inst_U_imm));
		]]
	},
	B = {
		verilog = [[
			$display("\tB: R(%d), R(%d), %d (%d)", inst_B_rs1, inst_B_rs2, inst_B_imm, $signed(inst_B_imm));
		]]
	},
	S = {
		cpp = [[{
			auto f = parseFormatS(word);
			TRACE(str(L"\tS: R(%d), R(%d), %d", f.rs1, f.rs2, f.imm));
		}]],		
		verilog = [[
			$display("\tS: R(%d), R(%d), %d (%d)", inst_S_rs1, inst_S_rs2, inst_S_imm, $signed(inst_S_imm));
		]]
	}
}

local instructions = {
	{
		mask = 0xfe00707f,
		data = 0x00000033,
		name = "ADD",
		format = "R",
		cpp = [[
			auto f = parseFormatR(word);
			R_s(f.rd) = R_s(f.rs1) + R_s(f.rs2);
		]],
		verilog = [[
			r[inst_R_rd] <= $signed(r[inst_R_rs1]) + $signed(r[inst_R_rs2]);
			`DECODE_DONE;
		]]
	},
	{
		mask = 0x0000707f,
		data = 0x00000013,
		name = "ADDI",
		format = "I",
        cpp = [[
			auto f = parseFormatI(word);
			R_s(f.rd) = R_s(f.rs1) + f.imm;
        ]],
		verilog = [[
			r[inst_I_rd] <= $signed(r[inst_I_rs1]) + $signed(inst_I_imm);
			`DECODE_DONE;
		]]		
	},
	{
		mask = 0x0000707f,
		data = 0x0000001b,
		name = "ADDIW",
		format = "I",
        cpp = [[
			auto f = parseFormatI(word);
			R(f.rd) = R(f.rs1) + f.imm;
        ]],
		verilog = [[
			r[inst_I_rd] <= r[inst_I_rs1] + inst_I_imm;
			`DECODE_DONE;
		]]
	},
	{
		mask = 0xfe00707f,
		data = 0x0000003b,
		name = "ADDW",
		format = "R",
		cpp = [[
			auto f = parseFormatR(word);
			R(f.rd) = R(f.rs1) + R(f.rs2);
		]],
		verilog = [[
			r[inst_R_rd] <= r[inst_R_rs1] + r[inst_R_rs2];
			`DECODE_DONE;
		]]
	},
	{
		mask = 0xf800707f,
		data = 0x0000302f,
		name = "AMOADD.D",
		format = "R"
	},
	{
		mask = 0xf800707f,
		data = 0x0000202f,
		name = "AMOADD.W",
		format = "R"
	},
	{
		mask = 0xf800707f,
		data = 0x6000302f,
		name = "AMOAND.D",
		format = "R"
	},
	{
		mask = 0xf800707f,
		data = 0x6000202f,
		name = "AMOAND.W",
		format = "R"
	},
	{
		mask = 0xf800707f,
		data = 0xe000302f,
		name = "AMOMAXU.D",
		format = "R"
	},
	{
		mask = 0xf800707f,
		data = 0xe000202f,
		name = "AMOMAXU.W",
		format = "R"
	},
	{
		mask = 0xf800707f,
		data = 0x4000302f,
		name = "AMOOR.D",
		format = "R"
	},
	{
		mask = 0xf800707f,
		data = 0x4000202f,
		name = "AMOOR.W",
		format = "R"
	},
	{
		mask = 0xf800707f,
		data = 0x0800302f,
		name = "AMOSWAP.D",
		format = "R"
	},
	{
		mask = 0xf800707f,
		data = 0x0800202f,
		name = "AMOSWAP.W",
		format = "R"
	},
	{
		mask = 0xfe00707f,
		data = 0x00007033,
		name = "AND",
		format = "R",
		cpp = [[
			auto f = parseFormatR(word);
			R_u(f.rd) = R_u(f.rs1) & R_u(f.rs2);
		]],
		verilog = [[
			r[inst_R_rd] <= r[inst_R_rs1] & r[inst_R_rs2];
			`DECODE_DONE;
		]]		
	},
	{
		mask = 0x0000707f,
		data = 0x00007013,
		name = "ANDI",
		format = "I",
        cpp = [[
			auto f = parseFormatI(word);
			R_u(f.rd) = R_u(f.rs1) & f.imm;
        ]],
		verilog = [[
			r[inst_I_rd] <= r[inst_I_rs1] & inst_I_imm;
			`DECODE_DONE;
		]]
	},
	{
		mask = 0x0000007f,
		data = 0x00000017,
		name = "AUIPC",
		format = "U",
		cpp = [[
			auto f = parseFormatU(word);
			R_u(f.rd) = PC + f.imm;
		]],
		verilog = [[
			r[inst_U_rd] <= $signed(pc) + $signed(inst_U_imm);
			`DECODE_DONE;
		]]
	},
	{
		mask = 0x0000707f,
		data = 0x00000063,
		name = "BEQ",
		format = "B",
		cpp = [[
			auto f = parseFormatB(word);
			if (R_s(f.rs1) == R_s(f.rs2))
				PC_NEXT = PC + f.imm;
		]],
		verilog = [[
			if (r[inst_B_rs1] == r[inst_B_rs2])
				pc_next <= $signed(pc) + $signed(inst_B_imm);
			`DECODE_DONE;
		]]
	},
	{
		mask = 0x0000707f,
		data = 0x00005063,
		name = "BGE",
		format = "B",
		cpp = [[
			auto f = parseFormatB(word);
			if (R_s(f.rs1) >= R_s(f.rs2))
				PC_NEXT = PC + f.imm;
		]],
		verilog = [[
			if ($signed(r[inst_B_rs1]) >= $signed(r[inst_B_rs2]))
				pc_next <= $signed(pc) + $signed(inst_B_imm);
			`DECODE_DONE;
		]]
	},
	{
		mask = 0x0000707f,
		data = 0x00007063,
		name = "BGEU",
		format = "B",
		cpp = [[
			auto f = parseFormatB(word);
			if (R_u(f.rs1) >= R_u(f.rs2))
				PC_NEXT = PC + f.imm;
		]],
		verilog = [[
			if (r[inst_B_rs1] >= r[inst_B_rs2])
				pc_next <= $signed(pc) + $signed(inst_B_imm);
			`DECODE_DONE;
		]]
	},
	{
		mask = 0x0000707f,
		data = 0x00004063,
		name = "BLT",
		format = "B",
		cpp = [[
			auto f = parseFormatB(word);
			if (R_s(f.rs1) < R_s(f.rs2))
				PC_NEXT = PC + f.imm;
		]],
		verilog = [[
			if ($signed(r[inst_B_rs1]) < $signed(r[inst_B_rs2]))
				pc_next <= $signed(pc) + $signed(inst_B_imm);
			`DECODE_DONE;
		]]
	},
	{
		mask = 0x0000707f,
		data = 0x00006063,
		name = "BLTU",
		format = "B",
		cpp = [[
			auto f = parseFormatB(word);
			if (R_u(f.rs1) < R_u(f.rs2))
				PC_NEXT = PC + f.imm;
		]],
		verilog = [[
			if (r[inst_B_rs1] < r[inst_B_rs2])
				pc_next <= $signed(pc) + $signed(inst_B_imm);
			`DECODE_DONE;
		]]
	},
	{
		mask = 0x0000707f,
		data = 0x00001063,
		name = "BNE",
		format = "B",
		cpp = [[
			auto f = parseFormatB(word);
			if (R_s(f.rs1) != R_s(f.rs2))
				PC_NEXT = PC + f.imm;
		]],
		verilog = [[
			if (r[inst_B_rs1] != r[inst_B_rs2])
				pc_next <= $signed(pc) + $signed(inst_B_imm);
			`DECODE_DONE;
		]]
	},
	{
		mask = 0x0000707f,
		data = 0x00003073,
		name = "CSRRC",
		format = "CSR"
	},
	{
		mask = 0x0000707f,
		data = 0x00007073,
		name = "CSRRCI",
		format = "CSR"
	},
	{
		mask = 0x0000707f,
		data = 0x00002073,
		name = "CSRRS",
		format = "CSR"
	},
	{
		mask = 0x0000707f,
		data = 0x00006073,
		name = "CSRRSI",
		format = "CSR"
	},
	{
		mask = 0x0000707f,
		data = 0x00001073,
		name = "CSRRW",
		format = "CSR"
	},
	{
		mask = 0x0000707f,
		data = 0x00005073,
		name = "CSRRWI",
		format = "CSR"
	},
	{
		mask = 0xfe00707f,
		data = 0x02004033,
		name = "DIV",
		format = "R",
		cpp = [[
			auto f = parseFormatR(word);
			int32_t dividend = R_s(f.rs1);
			int32_t divisor = R_s(f.rs2);
			if (divisor == 0)
				R_s(f.rd) = -1;
			else if (dividend == -std::numeric_limits< int32_t >::max() && divisor == -1)
				R_s(f.rd) = dividend;
			else
				R_s(f.rd) = dividend / divisor;
		]]
	},
	{
		mask = 0xfe00707f,
		data = 0x02005033,
		name = "DIVU",
		format = "R",
		cpp = [[
			auto f = parseFormatR(word);
			uint32_t dividend = R_u(f.rs1);
			uint32_t divisor = R_u(f.rs2);
			if (divisor ==  0)
				R_s(f.rd) = -1;
			else		
				R_u(f.rd) = dividend / divisor;
		]]
	},
	{
		mask = 0xfe00707f,
		data = 0x0200503b,
		name = "DIVUW",
		format = "R",
		cpp = [[
			auto f = parseFormatR(word);
			uint32_t dividend = R_u(f.rs1);
			uint32_t divisor = R_u(f.rs2);
			if (divisor ==  0)
				R_s(f.rd) = -1;
			else		
				R_u(f.rd) = dividend / divisor;
		]]
	},
	{
		mask = 0xfe00707f,
		data = 0x0200403b,
		name = "DIVW",
		format = "R",
		cpp = [[
			auto f = parseFormatR(word);
			R(f.rd) = R(f.rs1) / R(f.rs2);
		]]
	},
	{
		mask = 0xffffffff,
		data = 0x00100073,
		name = "EBREAK",
		format = "",
		verilog = [[
			$finish;
		]]
	},
	{
		mask = 0xffffffff,
		data = 0x00000073,
		name = "ECALL",
		format = "",
		cpp = [[
		]]
	},
	{
		mask = 0xfe00007f,
		data = 0x02000053,
		name = "FADD.D",
		format = "R"
	},
	{
		mask = 0xfff0007f,
		data = 0xd2200053,
		name = "FCVT.D.L",
		format = "R"
	},
	{
		mask = 0xfff0007f,
		data = 0x42000053,
		name = "FCVT.D.S",
		format = "R"
	},
	{
		mask = 0xfff0007f,
		data = 0xd2000053,
		name = "FCVT.D.W",
		format = "R"
	},
	{
		mask = 0xfff0007f,
		data = 0xd2100053,
		name = "FCVT.D.WU",
		format = "R"
	},
	{
		mask = 0xfff0007f,
		data = 0x40100053,
		name = "FCVT.S.D",
		format = "R"
	},
	{
		mask = 0xfff0007f,
		data = 0xc2000053,
		name = "FCVT.W.D",
		format = "R"
	},
	{
		mask = 0xfe00007f,
		data = 0x1a000053,
		name = "FDIV.D",
		format = "R"
	},
	{
		mask = 0x0000707f,
		data = 0x0000000f,
		name = "FENCE",
		format = ""
	},
	{
		mask = 0x0000707f,
		data = 0x0000100f,
		name = "FENCE.I",
		format = ""
	},
	{
		mask = 0xfe00707f,
		data = 0xa2002053,
		name = "FEQ.D",
		format = ""
	},
	{
		mask = 0x0000707f,
		data = 0x00003007,
		name = "FLD",
		format = "I"
	},
	{
		mask = 0xfe00707f,
		data = 0xa2000053,
		name = "FLE.D",
		format = "R"
	},
	{
		mask = 0xfe00707f,
		data = 0xa2001053,
		name = "FLT.D",
		format = "R"
	},
	{
		mask = 0x0000707f,
		data = 0x00002007,
		name = "FLW",
		format = "I"
	},
	{
		mask = 0x0600007f,
		data = 0x02000043,
		name = "FMADD.D",
		format = "R"
	},
	{
		mask = 0xfe00007f,
		data = 0x12000053,
		name = "FMUL.D",
		format = "R"
	},
	{
		mask = 0xfff0707f,
		data = 0xf2000053,
		name = "FMV.D.X",
		format = "R"
	},
	{
		mask = 0xfff0707f,
		data = 0xe2000053,
		name = "FMV.X.D",
		format = "R"
	},
	{
		mask = 0xfff0707f,
		data = 0xe0000053,
		name = "FMV.X.W",
		format = "R"
	},
	{
		mask = 0xfff0707f,
		data = 0xf0000053,
		name = "FMV.W.X",
		format = "R"
	},
	{
		mask = 0x0600007f,
		data = 0x0200004b,
		name = "FNMSUB.D",
		format = "R"
	},
	{
		mask = 0x0000707f,
		data = 0x00003027,
		name = "FSD",
		format = "S"
	},
	{
		mask = 0xfe00707f,
		data = 0x22000053,
		name = "FSGNJ.D",
		format = "R"
	},
	{
		mask = 0xfe00707f,
		data = 0x22002053,
		name = "FSGNJX.D",
		format = "R"
	},
	{
		mask = 0xfe00007f,
		data = 0x0a000053,
		name = "FSUB.D",
		format = "R"
	},
	{
		mask = 0x0000707f,
		data = 0x00002027,
		name = "FSW",
		format = "S"
	},
	{
		mask = 0x0000007f,
		data = 0x0000006f,
		name = "JAL",
		format = "J",
		cpp = [[
			auto f = parseFormatJ(word);
			R_u(f.rd) = PC_NEXT;
			PC_NEXT = PC + f.imm;
		]],
		verilog = [[
			r[inst_J_rd] <= pc_next;
			pc_next <= $signed(pc) + $signed(inst_J_imm);
			`DECODE_DONE;
		]]
	},
	{
		mask = 0x0000707f,
		data = 0x00000067,
		name = "JALR",
		format = "I",
		cpp = [[
			auto f = parseFormatI(word);
			R_u(f.rd) = PC_NEXT;
			PC_NEXT = R(f.rs1) + f.imm;
		]],
		verilog = [[
			r[inst_I_rd] <= pc_next;
			pc_next <= $signed(r[inst_I_rs1]) + $signed(inst_I_imm);
			`DECODE_DONE;
		]]
	},
	{
		mask = 0x0000707f,
		data = 0x00000003,
		name = "LB",
		format = "I",
		cpp = [[
			auto f = parseFormatI(word);
			R_s(f.rd) = (int8_t)MEM_RD_U8(R_u(f.rs1) + f.imm);
		]],
		verilog = [[
			// 1: fetch 32-bit word from memory.
			if (decode_step == 0) begin
				// $display("\tLOAD BYTE, address <= %x", r[inst_I_rs1] + $signed(inst_I_imm));
				`MEM_READ_REQ(r[inst_I_rs1] + $signed(inst_I_imm));
				decode_step <= 1;
			end
			// 2: wait until load finish.
			else if (decode_step == 1) begin
				if (`BUS_READY) begin
					// $display("\tLOAD BYTE, data => %x (%d)", i_data, address_byte);
					case ( address_byte  )
						2'b00: r[inst_I_rd] <= { { 24{ i_data[7]  } }, i_data[6:0] };
						2'b01: r[inst_I_rd] <= { { 24{ i_data[15] } }, i_data[14:8] };
						2'b10: r[inst_I_rd] <= { { 24{ i_data[23] } }, i_data[22:16] };
						2'b11: r[inst_I_rd] <= { { 24{ i_data[31] } }, i_data[30:24] };
					endcase
					`BUS_REQUEST_END;
					`DECODE_DONE;
				end
			end
		]]
	},
	{
		mask = 0x0000707f,
		data = 0x00004003,
		name = "LBU",
		format = "I",
		cpp = [[
			auto f = parseFormatI(word);
			R_u(f.rd) = MEM_RD_U8(R_u(f.rs1) + f.imm);
		]],
		verilog = [[
			// 1: fetch 32-bit word from memory.
			if (decode_step == 0) begin
				// $display("\tLOAD UBYTE, address %x", r[inst_I_rs1] + $signed(inst_I_imm));
				`MEM_READ_REQ(r[inst_I_rs1] + $signed(inst_I_imm));
				decode_step <= 1;
			end
			// 2: wait until load finish.
			else if (decode_step == 1) begin
				if (`BUS_READY) begin
					// $display("\tLOAD UBYTE, data => %x (%d)", i_data, address_byte);
					case ( address_byte  )
						2'b00: r[inst_I_rd] <= { 24'b0, i_data[7:0] };
						2'b01: r[inst_I_rd] <= { 24'b0, i_data[15:8] };
						2'b10: r[inst_I_rd] <= { 24'b0, i_data[23:16] };
						2'b11: r[inst_I_rd] <= { 24'b0, i_data[31:24] };
					endcase
					`BUS_REQUEST_END;
					`DECODE_DONE;
				end
			end
		]]		
	},
	{
		mask = 0x0000707f,
		data = 0x00003003,
		name = "LD",
		format = "I"
	},
	{
		mask = 0x0000707f,
		data = 0x00001003,
		name = "LH",
		format = "I",
		cpp = [[
			auto f = parseFormatI(word);
			R_s(f.rd) = (int16_t)MEM_RD_U16(R_u(f.rs1) + f.imm);
		]],
		verilog = [[
			if (decode_step == 0) begin
				// $display("\tLOAD SHALF, address <= %x", r[inst_I_rs1] + $signed(inst_I_imm));
				`MEM_READ_REQ(r[inst_I_rs1] + $signed(inst_I_imm));
				decode_step <= 1;
			end
			else if (decode_step == 1) begin
				if (`BUS_READY) begin
					// $display("\tLOAD HALF, data => %x (%d)", i_data, address_byte);
					case ( address_byte  )
						2'b00: r[inst_I_rd] <= { { 16{ i_data[15] } }, i_data[14:0] };
						2'b10: r[inst_I_rd] <= { { 16{ i_data[31] } }, i_data[30:16] };
					endcase
					`BUS_REQUEST_END;
					`DECODE_DONE;
				end
			end
		]]	
	},
	{
		mask = 0x0000707f,
		data = 0x00005003,
		name = "LHU",
		format = "I",
		cpp = [[
			auto f = parseFormatI(word);
			R(f.rd) = MEM_RD_U16(R(f.rs1) + f.imm);			
		]],
		verilog = [[
			if (decode_step == 0) begin
				// $display("\tLOAD HALF, address <= %x", r[inst_I_rs1] + $signed(inst_I_imm));
				`MEM_READ_REQ(r[inst_I_rs1] + $signed(inst_I_imm));
				decode_step <= 1;
			end
			else if (decode_step == 1) begin
				if (`BUS_READY) begin
					// $display("\tLOAD HALF, data => %x (%d)", i_data, address_byte);
					r[inst_I_rd] <= i_data[15:0];
					case ( address_byte  )
						2'b00: r[inst_I_rd] <= { 16'b0, i_data[15:0] };
						2'b10: r[inst_I_rd] <= { 16'b0, i_data[31:16] };
					endcase
					`BUS_REQUEST_END;
					`DECODE_DONE;
				end
			end
		]]
	},
	{
		mask = 0xf9f0707f,
		data = 0x1000302f,
		name = "LR.D",
		format = "R"
	},
	{
		mask = 0xf9f0707f,
		data = 0x1000202f,
		name = "LR.W",
		format = "R"
	},
	{
		mask = 0x0000007f,
		data = 0x00000037,
		name = "LUI",
		format = "U",
		cpp = [[
			auto f = parseFormatU(word);
			R_s(f.rd) = f.imm;
		]],
		verilog = [[
			r[inst_U_rd] <= inst_U_imm;
			`DECODE_DONE;
		]]
	},
	{
		mask = 0x0000707f,
		data = 0x00002003,
		name = "LW",
		format = "I",
		cpp = [[
			auto f = parseFormatI(word);
			R_s(f.rd) = (int32_t)MEM_RD(R_u(f.rs1) + f.imm);
		]],
		verilog = [[
			if (decode_step == 0) begin
				$display("\tLOAD WORD, address <= %x", r[inst_I_rs1] + $signed(inst_I_imm));
				`MEM_READ_REQ(r[inst_I_rs1] + $signed(inst_I_imm));
				decode_step <= 1;
			end
			else if (decode_step == 1) begin
				if (`BUS_READY) begin
					$display("\tLOAD WORD, data => %x", i_data);
					r[inst_I_rd] <= i_data;
					`BUS_REQUEST_END;
					`DECODE_DONE;
				end
			end
		]]
	},
	{
		mask = 0x0000707f,
		data = 0x00006003,
		name = "LWU",
		format = "I",
		cpp = [[
			auto f = parseFormatI(word);
			R_u(f.rd) = MEM_RD(R_u(f.rs1) + f.imm);
		]],
		verilog = [[
			if (decode_step == 0) begin
				`MEM_READ_REQ(r[inst_I_rs1] + inst_I_imm);
				decode_step <= 1;
			end
			else if (decode_step == 1) begin
				if (`BUS_READY) begin
					r[inst_I_rd] <= i_data[31:0];
					`BUS_REQUEST_END;
					`DECODE_DONE;
				end
			end
		]]
	},
	{
		mask = 0xfe00707f,
		data = 0x02000033,
		name = "MUL",
		format = "R",
		cpp = [[
			auto f = parseFormatR(word);
			R_s(f.rd) = R_s(f.rs1) * R_s(f.rs2);
		]],
		verilog = [[
			r[inst_R_rd] <= $signed(r[inst_R_rs1]) * $signed(r[inst_R_rs2]);
			`DECODE_DONE;
		]]
	},
	{
		mask = 0xfe00707f,
		data = 0x02001033,
		name = "MULH",
		format = "R",
		cpp = [[
			auto f = parseFormatR(word);
			int64_t lh = (int64_t)R_s(f.rs1);
			int64_t rh = (int64_t)R_s(f.rs2);
			R_s(f.rd) = (lh * rh) >> 32;
		]]
	},
	{
		mask = 0xfe00707f,
		data = 0x02003033,
		name = "MULHU",
		format = "R",
		cpp = [[
			auto f = parseFormatR(word);
			uint64_t lh = (uint64_t)R(f.rs1);
			uint64_t rh = (uint64_t)R(f.rs2);
			R(f.rd) = (lh * rh) >> 32;
		]]
	},
	{
		mask = 0xfe00707f,
		data = 0x02002033,
		name = "MULHSU",
		format = "R"
	},
	{
		mask = 0xfe00707f,
		data = 0x0200003b,
		name = "MULW",
		format = "R"
	},
	{
		mask = 0xffffffff,
		data = 0x30200073,
		name = "MRET",
		format = ""
	},
	{
		mask = 0xfe00707f,
		data = 0x00006033,
		name = "OR",
		format = "R",
		cpp = [[
			auto f = parseFormatR(word);
			R_u(f.rd) = R_u(f.rs1) | R_u(f.rs2);
		]],
		verilog = [[
			r[inst_R_rd] <= r[inst_R_rs1] | r[inst_R_rs2];
			`DECODE_DONE;
		]]
	},
	{
		mask = 0x0000707f,
		data = 0x00006013,
		name = "ORI",
		format = "I",
		cpp = [[
			auto f = parseFormatI(word);
			R_u(f.rd) = R_u(f.rs1) | f.imm;
		]],
		verilog = [[
			r[inst_I_rd] <= r[inst_I_rs1] | inst_I_imm;
			`DECODE_DONE;
		]]
	},
	{
		mask = 0xfe00707f,
		data = 0x02006033,
		name = "REM",
		format = "R",
		cpp = [[
			auto f = parseFormatR(word);
			int32_t dividend = R_s(f.rs1);
			int32_t divisor = R_s(f.rs2);
			if (divisor == 0)
				R_s(f.rd) = dividend;
			else
				R_s(f.rd) = dividend % divisor;
		]]
	},
	{
		mask = 0xfe00707f,
		data = 0x02007033,
		name = "REMU",
		format = "R",
		cpp = [[
			auto f = parseFormatR(word);
			uint32_t dividend = R_u(f.rs1);
			uint32_t divisor = R_u(f.rs2);
			if (divisor == 0)
				R_u(f.rd) = dividend;
			else
				R_u(f.rd) = dividend % divisor;
		]]
	},
	{
		mask = 0xfe00707f,
		data = 0x0200703b,
		name = "REMUW",
		format = "R"
	},
	{
		mask = 0xfe00707f,
		data = 0x0200603b,
		name = "REMW",
		format = "R"
	},
	{
		mask = 0x0000707f,
		data = 0x00000023,
		name = "SB",
		format = "S",
		cpp = [[
			auto f = parseFormatS(word);
			MEM_WR_U8(R_u(f.rs1) + f.imm, (uint8_t)R_u(f.rs2));
		]],
		verilog = [[
			// 1: fetch 32-bit word from memory.
			if (decode_step == 0) begin
				// $display("\tSTORE BYTE, address %x", r[inst_S_rs1] + $signed(inst_S_imm));
				`MEM_READ_REQ(r[inst_S_rs1] + $signed(inst_S_imm));
				decode_step <= 1;
			end
			// 2: patch into word after load finished.
			else if (decode_step == 1) begin
				if (`BUS_READY) begin
					$display("\tSTORE BYTE, address %x, patch %d, i_data %x, value %x", o_address, address_byte, i_data, r[inst_S_rs2][7:0]);
					case ( address_byte  )
						2'b00: o_data <= {      i_data[31:24],      i_data[23:16],       i_data[15:8], r[inst_S_rs2][7:0] };
						2'b01: o_data <= {      i_data[31:24],      i_data[23:16], r[inst_S_rs2][7:0],        i_data[7:0] };
						2'b10: o_data <= {      i_data[31:24], r[inst_S_rs2][7:0],       i_data[15:8],        i_data[7:0] };
						2'b11: o_data <= { r[inst_S_rs2][7:0],      i_data[23:16],       i_data[15:8],        i_data[7:0] };
					endcase
					`BUS_REQUEST_END;
					decode_step <= 2;
				end
			end
			// 3: store 32-bit word into memory.
			else if (decode_step == 2) begin
				o_rw <= 1;
				request <= 1;
				decode_step <= 3;
			end
			// 4: wait until store finished.
			else if (decode_step == 3) begin
				if (`BUS_READY) begin
					// $display("\tSTORE BYTE, address %x, patch %d, o_data %x", o_address, address_byte, o_data);
					o_rw <= 0;
					`BUS_REQUEST_END;
					`DECODE_DONE;
				end
			end
		]]
	},
	{
		mask = 0xf800707f,
		data = 0x1800302f,
		name = "SC.D",
		format = "R"
	},
	{
		mask = 0xf800707f,
		data = 0x1800202f,
		name = "SC.W",
		format = "R"
	},
	{
		mask = 0x0000707f,
		data = 0x00003023,
		name = "SD",
		format = "S"
	},
	{
		mask = 0xfe007fff,
		data = 0x12000073,
		name = "SFENCE.VMA",
		format = ""
	},
	{
		mask = 0x0000707f,
		data = 0x00001023,
		name = "SH",
		format = "S",
		cpp = [[
			auto f = parseFormatS(word);
			MEM_WR_U16(R_u(f.rs1) + f.imm, R_u(f.rs2));
		]],
		verilog = [[
			// 1: fetch 32-bit word from memory.
			if (decode_step == 0) begin
				// $display("\tSTORE HALF, address %x", r[inst_S_rs1] + $signed(inst_S_imm));
				`MEM_READ_REQ(r[inst_S_rs1] + $signed(inst_S_imm));
				decode_step <= 1;
			end
			// 2: patch into word after load finished.
			else if (decode_step == 1) begin
				if (`BUS_READY) begin
					case ( address_byte  )
						2'b00: o_data <= {       i_data[31:16], r[inst_S_rs2][15:0] };
						2'b10: o_data <= { r[inst_S_rs2][15:0],        i_data[15:0] };
					endcase
					`BUS_REQUEST_END;
					decode_step <= 2;
				end
			end
			// 3: store 32-bit word into memory.
			else if (decode_step == 2) begin
				o_rw <= 1;
				request <= 1;
				decode_step <= 3;
			end
			// 4: wait until store finished.
			else if (decode_step == 3) begin
				if (`BUS_READY) begin
					o_rw <= 0;
					`BUS_REQUEST_END;
					`DECODE_DONE;
				end
			end
		]]
	},
	{
		mask = 0xfe00707f,
		data = 0x00001033,
		name = "SLL",
		format = "R",
		cpp = [[
			auto f = parseFormatR(word);
			R_s(f.rd) = R_s(f.rs1) << R_u(f.rs2);
		]],
		verilog = [[
			r[inst_R_rd] <= r[inst_R_rs1] << r[inst_R_rs2];
			`DECODE_DONE;
		]]
	},
	{
		mask = 0xfc00707f,
		data = 0x00001013,
		name = "SLLI",
		format = "R",
		cpp = [[
			auto f = parseFormatR(word);
			R_s(f.rd) = R_s(f.rs1) << ((word >> 20) & 0x1f);
		]],
		verilog = [[
			r[inst_R_rd] <= r[inst_R_rs1] << instruction[25:20];
			`DECODE_DONE;
		]]
	},
	{
		mask = 0xfe00707f,
		data = 0x0000101b,
		name = "SLLIW",
		format = "R"
	},
	{
		mask = 0xfe00707f,
		data = 0x0000103b,
		name = "SLLW",
		format = "R"
	},
	{
		mask = 0xfe00707f,
		data = 0x00002033,
		name = "SLT",
		format = "R",
		cpp = [[
			auto f = parseFormatR(word);
			R_u(f.rd) = (R_s(f.rs1) < R_s(f.rs2)) ? 1 : 0;
		]],
		verilog = [[
			r[inst_R_rd] <= ($signed(r[inst_R_rs1]) < $signed(r[inst_R_rs2])) ? 1 : 0;
			`DECODE_DONE;
		]]
	},
	{
		mask = 0x0000707f,
		data = 0x00002013,
		name = "SLTI",
		format = "I",
		cpp = [[
			auto f = parseFormatI(word);
			R_u(f.rd) = (R_s(f.rs1) < f.imm) ? 1 : 0;
		]],
		verilog = [[
			r[inst_I_rd] <= ($signed(r[inst_I_rs1]) < $signed(inst_I_imm)) ? 1 : 0;
			`DECODE_DONE;
		]]
	},
	{
		mask = 0x0000707f,
		data = 0x00003013,
		name = "SLTIU",
		format = "I",
		cpp = [[
			auto f = parseFormatI(word);
			R_u(f.rd) = (R_u(f.rs1) < f.imm) ? 1 : 0;
		]],
		verilog = [[
			r[inst_I_rd] <= (r[inst_I_rs1] < inst_I_imm) ? 1 : 0;
			`DECODE_DONE;
		]]
	},
	{
		mask = 0xfe00707f,
		data = 0x00003033,
		name = "SLTU",
		format = "R",
		cpp = [[
			auto f = parseFormatR(word);
			R_u(f.rd) = (R_u(f.rs1) < R_u(f.rs2)) ? 1 : 0;
		]],
		verilog = [[
			r[inst_R_rd] <= (r[inst_R_rs1] < r[inst_R_rs2]) ? 1 : 0;
			`DECODE_DONE;
		]]
	},
	{
		mask = 0xfe00707f,
		data = 0x40005033,
		name = "SRA",
		format = "R",
		cpp = [[
			auto f = parseFormatR(word);
			R_s(f.rd) = R_s(f.rs1) >> R_u(f.rs2);
		]]
	},
	{
		mask = 0xfc00707f,
		data = 0x40005013,
		name = "SRAI",
		format = "R",
		cpp = [[
			auto f = parseFormatR(word);
			R_s(f.rd) = R_s(f.rs1) >> ((word >> 20) & 0x1f);
		]],
		verilog = [[
			r[inst_R_rd] <= r[inst_R_rs1] >>> instruction[25:20];
			`DECODE_DONE;
		]]
	},
	{
		mask = 0xfc00707f,
		data = 0x4000501b,
		name = "SRAIW",
		format = "R"
	},
	{
		mask = 0xfe00707f,
		data = 0x4000503b,
		name = "SRAW",
		format = "R"
	},
	{
		mask = 0xffffffff,
		data = 0x10200073,
		name = "SRET",
		format = ""
	},
	{
		mask = 0xfe00707f,
		data = 0x00005033,
		name = "SRL",
		format = "R",
		cpp = [[
			auto f = parseFormatR(word);
			R_u(f.rd) = R_u(f.rs1) >> R_u(f.rs2);
		]]
	},
	{
		mask = 0xfc00707f,
		data = 0x00005013,
		name = "SRLI",
		format = "R",
		cpp = [[
			auto f = parseFormatR(word);
			R_u(f.rd) = R_u(f.rs1) >> ((word >> 20) & 0x1f);
		]],
		verilog = [[
			r[inst_R_rd] <= r[inst_R_rs1] >> instruction[25:20];
			`DECODE_DONE;
		]]
	},
	{
		mask = 0xfc00707f,
		data = 0x0000501b,
		name = "SRLIW",
		format = "R"
	},
	{
		mask = 0xfe00707f,
		data = 0x0000503b,
		name = "SRLW",
		format = "R"
	},
	{
		mask = 0xfe00707f,
		data = 0x40000033,
		name = "SUB",
		format = "R",
		cpp = [[
			auto f = parseFormatR(word);
			R_s(f.rd) = R_s(f.rs1) - R_s(f.rs2);
		]],
		verilog = [[
			r[inst_R_rd] <= $signed(r[inst_R_rs1]) - $signed(r[inst_R_rs2]);
			`DECODE_DONE;
		]]
	},
	{
		mask = 0xfe00707f,
		data = 0x4000003b,
		name = "SUBW",
		format = "R"
	},
	{
		mask = 0x0000707f,
		data = 0x00002023,
		name = "SW",
		format = "S",
		cpp = [[
			auto f = parseFormatS(word);
			MEM_WR(R_u(f.rs1) + f.imm, R_u(f.rs2));
		]],
		verilog = [[
			if (decode_step == 0) begin
				$display("\tSTORE WORD, address %x, value %x", r[inst_S_rs1] + $signed(inst_S_imm), r[inst_S_rs2]);
				`MEM_WRITE_REQ(r[inst_S_rs1] + $signed(inst_S_imm), r[inst_S_rs2]);
				decode_step <= 1;
			end
			else if (decode_step == 1) begin
				if (`BUS_READY) begin
					o_rw <= 0;
					`BUS_REQUEST_END;
					`DECODE_DONE;
				end
			end			
		]]
	},
	{
		mask = 0xffffffff,
		data = 0x00200073,
		name = "URET",
		format = ""
	},
	{
		mask = 0xffffffff,
		data = 0x10500073,
		name = "WFI",
		format = ""
	},
	{
		mask = 0xfe00707f,
		data = 0x00004033,
		name = "XOR",
		format = "R",
		cpp = [[
			auto f = parseFormatR(word);
			R_u(f.rd) = R_u(f.rs1) ^ R_u(f.rs2);
		]],
		verilog = [[
			r[inst_R_rd] <= r[inst_R_rs1] ^ r[inst_R_rs2];
			`DECODE_DONE;
		]]
	},
	{
		mask = 0x0000707f,
		data = 0x00004013,
		name = "XORI",
		format = "I",
		cpp = [[
			auto f = parseFormatI(word);
			R_u(f.rd) = R_u(f.rs1) ^ f.imm;
		]],
		verilog = [[
			r[inst_I_rd] <= r[inst_I_rs1] ^ inst_I_imm;
			`DECODE_DONE;
		]]	
	},
}

local function trim(s)
   return s:match'^%s*(.*%S)' or ''
end

local function lines(s)
	if s:sub(-1)~="\n" then s=s.."\n" end
	return string.gmatch(s,'[^\r\n]+')
end

function main(argv)

	local language = argv:get(0)
	local debug = true

	if language == "cpp" then

		for i, inst in ipairs(instructions) do
			assert((inst.mask & inst.data) == inst.data)
			if i > 1 then stdout:print("else if") else stdout:print("if") end
			stdout:printLn(" ((word & 0x" .. string.format("%08x", inst.mask) .. ") == 0x" .. string.format("%08x", inst.data) .. ")")
			stdout:printLn("{")
			stdout:printLn("\tTRACE(L\"\t" .. inst.name .. "\");")
			local pfx = prefixes[inst.format];
			if pfx ~= nil and pfx.cpp ~= nil then
				stdout:printLn("\t" .. trim(pfx.cpp))
			end
			if inst.cpp ~= nil then
				stdout:printLn(inst.cpp)
				stdout:printLn("\treturn true;")
			else
				stdout:printLn("\tlog::error << L\"Not implemented.\" << Endl;")
				stdout:printLn("\treturn false;")
			end
			stdout:printLn("}")
		end
		stdout:printLn("else")
		stdout:printLn("{")
		stdout:printLn("\tlog::error << L\"Unknown instruction.\" << Endl;")
		stdout:printLn("\treturn false;")
		stdout:printLn("}")

	elseif language == "verilog_decode" then 
		stdout:printLn("// This file is automatically generated, DO NOT EDIT!")
		stdout:printLn("// ==================================================")

		local count = 0
		for prefix, _ in pairs(prefixes) do
			local t = {}
			for i, inst in ipairs(instructions) do
				if inst.verilog ~= nil and inst.format == prefix then
					table.insert(t, inst)
				end
			end
			if #t > 0 then
				if count > 1 then stdout:print("else if") else stdout:print("if") end
				stdout:printLn(" (is_" .. prefix .. ") begin")
				for i, inst in ipairs(t) do
					stdout:printLn("")
					stdout:printLn("\t// " .. inst.name)
					if i > 1 then stdout:print("\telse if") else stdout:print("\tif") end
					stdout:printLn(" (is_" .. inst.name .. ") begin")
					if debug then
						stdout:printLn("\t\t$display(\"\t" .. inst.name .. "\");")
						local pfx = prefixes[inst.format];
						if pfx ~= nil and pfx.verilog ~= nil then
							stdout:printLn("\t\t" .. trim(pfx.verilog))
						end
					end
					for ln in lines(inst.verilog) do
						if #ln > 0 then
							stdout:printLn("\t" .. ln)
						end
					end
					stdout:printLn("\tend")
				end
				stdout:printLn("")
				stdout:printLn("end")
				count = count + 1
			end
		end

		-- Non format, such as EBREAK
		local t = {}
		for i, inst in ipairs(instructions) do
			if inst.verilog ~= nil and inst.format == "" then
				table.insert(t, inst)
			end
		end
		for i, inst in ipairs(t) do
			stdout:printLn("")
			stdout:printLn("// " .. inst.name)
			if i > 1 then stdout:print("\telse if") else stdout:print("\tif") end
			stdout:printLn(" (is_" .. inst.name .. ") begin")
			if debug then
				stdout:printLn("\t$display(\"\t" .. inst.name .. "\");")
				local pfx = prefixes[inst.format];
				if pfx ~= nil and pfx.verilog ~= nil then
					stdout:printLn("\t" .. trim(pfx.verilog))
				end
			end
			for ln in lines(inst.verilog) do
				if #ln > 0 then
					stdout:printLn(ln)
				end
			end
			stdout:printLn("end")
		end

	elseif language == "verilog_inst_wire" then

		stdout:printLn("// This file is automatically generated, DO NOT EDIT!")
		stdout:printLn("// ==================================================")
		for i, inst in ipairs(instructions) do
			if inst.verilog ~= nil then
				stdout:printLn("wire is_" .. inst.name .. " = ((instruction & 32'h" .. string.format("%08x", inst.mask) .. ") == 32'h" .. string.format("%08x", inst.data) .. ");")
			end
		end
		stdout:printLn("")
		for prefix, _ in pairs(prefixes) do
			local t = {}
			for i, inst in ipairs(instructions) do
				if inst.verilog ~= nil and inst.format == prefix then
					table.insert(t, inst)
				end
			end
			if #t > 0 then
				stdout:print("wire is_" .. prefix .. " =")
				for i, inst in ipairs(t) do

					if i > 1 then stdout:print(" ||") end
					stdout:print(" is_" .. inst.name)

				end
				stdout:printLn(";")
			end
		end

	else
		stderr:printLn("Unknown language \"" .. language .. "\".")
	end
end
